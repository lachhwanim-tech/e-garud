"use client"

import React from "react"

import { useState, useEffect, useCallback } from "react"
import type { 
  CrewData, 
  Abnormality, 
  AbnormalitySummary, 
  CliData,
  StationSignalData,
  CrewRecord
} from "@/types/dashboard"
import type { Toast } from "@/components/dashboard/toast-container"

const initialCrewData: CrewData = {
  id: "",
  name: "",
  designation: "",
  groupCli: "",
  cugNumber: "",
}

const initialAbnormalitySummary: AbnormalitySummary = {
  bftNotDone: 0,
  bptNotDone: 0,
  bftRule: 0,
  bptRule: 0,
  lateControlling: 0,
  overspeeding: 0,
  others: 0,
}

const initialCliData: CliData = {
  name: "",
  hq: "",
}

export function useDashboardLogic() {
  const [isLoading, setIsLoading] = useState(false)
  const [lpData, setLpData] = useState<CrewData>(initialCrewData)
  const [alpData, setAlpData] = useState<CrewData>(initialCrewData)
  const [lpAbnormalities, setLpAbnormalities] = useState<Abnormality[]>([])
  const [abnormalitySummary, setAbnormalitySummary] = useState<AbnormalitySummary>(initialAbnormalitySummary)
  const [sections, setSections] = useState<string[]>([])
  const [stations, setStations] = useState<string[]>([])
  const [cliData, setCliData] = useState<CliData>(initialCliData)
  const [toasts, setToasts] = useState<Toast[]>([])
  
  // Data stores
  const [crewData, setCrewData] = useState<CrewRecord[]>([])
  const [stationSignalData, setStationSignalData] = useState<StationSignalData[]>([])
  const [cliDataMap, setCliDataMap] = useState<Record<string, CliData>>({})
  const [currentScript, setCurrentScript] = useState<string | null>(null)

  // Toast functions
  const showToast = useCallback((message: string) => {
    const id = Date.now().toString()
    setToasts((prev) => [...prev, { id, message }])
  }, [])

  const removeToast = useCallback((id: string) => {
    setToasts((prev) => prev.filter((t) => t.id !== id))
  }, [])

  // Load initial data
  useEffect(() => {
    async function loadData() {
      try {
        // Load crew data from Google Sheet
        const CREW_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRCXMXkdxzxwCvZtN3uwLGQCmXqmadXbckJrWGtCqaw_ETO1Ci40WysmoqKVVPHpg_7_Exf_AmAxAjy/pub?gid=528051557&single=true&output=csv'
        const crewResponse = await fetch(CREW_CSV_URL)
        const crewText = await crewResponse.text()
        const crewParsed = parseCSV(crewText, true)
        setCrewData(crewParsed as CrewRecord[])
        
        // Make available globally for external scripts
        if (typeof window !== 'undefined') {
          (window as Window & { crewData?: CrewRecord[] }).crewData = crewParsed as CrewRecord[]
        }

        // Load station signal data
        const SIGNAL_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vT9Y1hcPadG8CzhtOHddc2XT013TJm9D7J7pZaWORapXpFFMoI4dpFp9PV21XNNk3UuSXFpBqU3KX5m/pub?gid=1398384533&single=true&output=csv'
        const signalResponse = await fetch(SIGNAL_CSV_URL)
        const signalText = await signalResponse.text()
        const signalParsed = parseCSV(signalText, true) as StationSignalData[]
        setStationSignalData(signalParsed)
        
        if (typeof window !== 'undefined') {
          (window as Window & { stationSignalData?: StationSignalData[] }).stationSignalData = signalParsed
        }

        // Extract unique sections
        const uniqueSections = [...new Set(signalParsed.map(row => row['SECTION']))].filter(Boolean)
        setSections(uniqueSections)

        console.log("Data loaded successfully")
      } catch (error) {
        console.error("Error loading data:", error)
      }
    }

    loadData()
  }, [])

  // Simple CSV parser
  function parseCSV(text: string, transformHeader = false): Record<string, string>[] {
    const lines = text.split('\n')
    if (lines.length < 2) return []
    
    let headers = lines[0].split(',').map(h => transformHeader ? h.trim().toUpperCase() : h.trim())
    const result: Record<string, string>[] = []
    
    for (let i = 1; i < lines.length; i++) {
      const line = lines[i].trim()
      if (!line) continue
      
      const values = line.split(',')
      const row: Record<string, string> = {}
      
      headers.forEach((header, idx) => {
        row[header] = values[idx]?.trim() || ''
      })
      
      result.push(row)
    }
    
    return result
  }

  // Fetch LP abnormalities
  async function fetchLpAbnormalities(lpId: string | null) {
    if (!lpId) {
      setLpAbnormalities([])
      setAbnormalitySummary(initialAbnormalitySummary)
      return
    }

    const PRIMARY_BANK_CSV = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vT5A-LI7taO45zhdBz1xdbFZx694C4OK1vpPSV6rVs5VXVpVjqIWuMZdVWKJaFcVIws5qC8ei1Gz9wg/pub?gid=0&single=true&output=csv'

    try {
      const response = await fetch(PRIMARY_BANK_CSV)
      const text = await response.text()
      const results = parseCSV(text)
      const lpRecords = results.filter(row => row['LP ID'] === lpId)

      if (lpRecords.length === 0) {
        setLpAbnormalities([])
        return
      }

      const counts = { bft: 0, bpt: 0, bftR: 0, bptR: 0, late: 0, speed: 0, other: 0 }
      const abnormalities: Abnormality[] = []

      lpRecords.slice(-10).reverse().forEach(r => {
        const abn = r['Abnormalities'] || ''
        if (abn.includes("BFT not done")) counts.bft++
        if (abn.includes("BPT not done")) counts.bpt++
        if (abn.includes("Late Controlling")) counts.late++
        if (abn.includes("Over speeding")) counts.speed++
        
        abnormalities.push({
          timestamp: r['Timestamp'] || '',
          description: abn
        })
      })

      setLpAbnormalities(abnormalities)
      setAbnormalitySummary({
        bftNotDone: counts.bft,
        bptNotDone: counts.bpt,
        bftRule: counts.bftR,
        bptRule: counts.bptR,
        lateControlling: counts.late,
        overspeeding: counts.speed,
        others: counts.other,
      })
    } catch (error) {
      console.error("Error fetching abnormalities:", error)
      setLpAbnormalities([])
    }
  }

  // Handle LP ID change
  const handleLpIdChange = useCallback((value: string) => {
    setLpData(prev => ({ ...prev, id: value }))
    
    const lpRecord = crewData.find(record => record['CREWID'] === value)
    if (lpRecord) {
      setLpData({
        id: value,
        name: lpRecord['CREW NAME'] || '',
        designation: lpRecord['DESG'] || '',
        groupCli: lpRecord['CLI NAME'] || '',
        cugNumber: lpRecord['CUG NUMBER'] || '',
      })
      fetchLpAbnormalities(value)
    } else {
      setLpData({ ...initialCrewData, id: value })
      fetchLpAbnormalities(null)
    }
  }, [crewData])

  // Handle ALP ID change
  const handleAlpIdChange = useCallback((value: string) => {
    setAlpData(prev => ({ ...prev, id: value }))
    
    const alpRecord = crewData.find(record => record['CREWID'] === value)
    if (alpRecord) {
      setAlpData({
        id: value,
        name: alpRecord['CREW NAME'] || '',
        designation: alpRecord['DESG'] || '',
        groupCli: alpRecord['CLI NAME'] || '',
        cugNumber: alpRecord['CUG NUMBER'] || '',
      })
    } else {
      setAlpData({ ...initialCrewData, id: value })
    }
  }, [crewData])

  // Handle section change
  const handleSectionChange = useCallback((section: string) => {
    const stationsInSection = [...new Set(
      stationSignalData
        .filter(row => row['SECTION'] === section)
        .map(row => row['STATION'])
    )].filter(Boolean)
    setStations(stationsInSection)
  }, [stationSignalData])

  // Handle CLI ID change
  const handleCliIdChange = useCallback((value: string) => {
    if (cliDataMap[value]) {
      setCliData(cliDataMap[value])
    } else {
      setCliData(initialCliData)
    }
  }, [cliDataMap])

  // Manual entry handlers
  const handleManualLpEntry = useCallback(() => {
    // This would enable manual editing in a real implementation
    console.log("Manual LP entry mode enabled")
  }, [])

  const handleManualAlpEntry = useCallback(() => {
    console.log("Manual ALP entry mode enabled")
  }, [])

  // Handle SPM type change
  const handleSpmTypeChange = useCallback((spmType: string) => {
    const fileInput = document.getElementById('spmFile') as HTMLInputElement
    if (!fileInput) return

    if (spmType === 'Medha') {
      fileInput.accept = '.txt'
    } else if (spmType === 'MR' || spmType === 'VEL') {
      fileInput.accept = '.pdf'
    } else if (spmType === 'RTIS') {
      fileInput.accept = '.xlsx,.xls,.csv'
    } else if (spmType === 'TelproNew') {
      fileInput.accept = '.xlsx,.xls'
    } else {
      fileInput.accept = '.xlsx,.xls,.csv'
    }

    setCurrentScript(`${spmType}.js`)
    console.log(`Script set to: ${spmType}.js`)
  }, [])

  // Form submit handler
  const handleFormSubmit = useCallback(async (e: React.FormEvent) => {
    e.preventDefault()
    
    const cliIdVal = (document.getElementById('cliIdInput') as HTMLInputElement)?.value
    if (!cliIdVal) {
      alert("Please enter a valid CLI ID.")
      return
    }

    const spmType = (document.getElementById('spmType') as HTMLSelectElement)?.value
    const spmFile = (document.getElementById('spmFile') as HTMLInputElement)?.files?.[0]

    if (!spmType) {
      alert('Please select an SPM Type.')
      return
    }
    if (!spmFile) {
      alert('Please upload an SPM file.')
      return
    }

    const fileExt = spmFile.name.split('.').pop()?.toLowerCase()

    // File extension validation
    if (['Laxven', 'Telpro'].includes(spmType) && !['xlsx', 'xls'].includes(fileExt || '')) {
      alert(`Please upload an Excel file (.xlsx or .xls) for ${spmType} SPM.`)
      return
    } else if (spmType === 'RTIS' && !['xlsx', 'xls', 'csv'].includes(fileExt || '')) {
      alert('Please upload an Excel (.xlsx/.xls) or CSV (.csv) file for RTIS SPM.')
      return
    } else if (spmType === 'Medha' && fileExt !== 'txt') {
      alert('Please upload a .txt file for Medha SPM.')
      return
    } else if ((spmType === 'MR' || spmType === 'VEL') && fileExt !== 'pdf') {
      alert('Please upload a .pdf file for MR or VEL SPM.')
      return
    } else if (spmType === 'TelproNew' && !['xlsx', 'xls'].includes(fileExt || '')) {
      alert(`Please upload an Excel file (.xlsx or .xls) for ${spmType} SPM.`)
      return
    }

    if (!currentScript) {
      alert(`No script loaded for SPM Type: ${spmType}. Please select SPM Type first.`)
      return
    }

    // Store HQ in localStorage
    const hqValueToSave = (document.getElementById('cliHqDisplay') as HTMLInputElement)?.value?.trim()
    localStorage.setItem('currentSessionHq', hqValueToSave || '')

    setIsLoading(true)

    try {
      showToast('Processing SPM data...')
      
      // Simulate processing
      await new Promise(resolve => setTimeout(resolve, 2000))
      
      showToast('Analysis complete!')
    } catch (error) {
      console.error('Error during processing:', error)
      alert('An error occurred: ' + (error as Error).message)
    } finally {
      setIsLoading(false)
    }
  }, [currentScript, showToast])

  // Expose toggleLoadingOverlay globally
  useEffect(() => {
    if (typeof window !== 'undefined') {
      (window as Window & { toggleLoadingOverlay?: (show: boolean) => void }).toggleLoadingOverlay = (show: boolean) => {
        setIsLoading(show)
      }
    }
  }, [])

  return {
    isLoading,
    lpData,
    alpData,
    lpAbnormalities,
    abnormalitySummary,
    sections,
    stations,
    handleLpIdChange,
    handleAlpIdChange,
    handleSectionChange,
    handleCliIdChange,
    cliData,
    handleManualLpEntry,
    handleManualAlpEntry,
    handleSpmTypeChange,
    handleFormSubmit,
    showToast,
    toasts,
    removeToast
  }
}
