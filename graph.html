<script>
    // --- 1. CONFIGURATION ---
    const API_KEY = 'AIzaSyAw23pJz0K9fZb2rRRAe2C2cJDilRc0Kac'; 
    const SHEET_ID = '1qYmIAKzt4rAVP0BPTTipzdOgIrwus6P-oGNf5HVekJM'; // Dashboard Sheet ID
    const RANGE = 'Sheet1!A:W'; // UPDATED: Sirf W tak (23 Columns)

    // --- 2. UPDATED COLUMN MAPPING (23-Column Structure) ---
    const COLS = {
        TIMESTAMP: 0,       // Col A
        CLI_ID: 1,          // Col B
        LP_ID: 3,           // Col D
        NAME: 4,            // Col E (LP Name)
        SECTION: 11,        // Col L
        FROM_LOC: 12,       // Col M
        TO_LOC: 13,         // Col N
        RAKE_TYPE: 14,      // Col O
        STOPS_JSON: 21      // Col V (Sara data iske andar hai)
    };

    // ... Baaki variables same rahenge ...
    const LINE_LIMIT = 50; 
    const COLOR_PALETTE = [
        '#e6194B', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4', '#42d4f4', '#f032e6',
        '#bfef45', '#fabed4', '#469990', '#dcbeff', '#9A6324', '#fffac8', '#800000', '#aaffc3',
        '#808000', '#ffd8b1', '#000075', '#a9a9a9'
    ];

    let myChart;
    let processedData = []; 
    let lpSet = new Set();
    let locationSet = new Set();
    const loadingDiv = document.getElementById('loading');
    const chartDiv = document.getElementById('chart-container');
    const filtersPanel = document.getElementById('filters-panel');
    let chartBaseOption; 
    let showOnlyAverage = false; 

    // Date Parser Helper
    function parseDate(timestampStr) {
        if (!timestampStr) return null;
        const datePart = timestampStr.toString().split('T')[0]; 
        return new Date(datePart);
    }

    function formatDateToInput(date) {
        if (!date) return '';
        const year = date.getFullYear();
        const month = (date.getMonth() + 1).toString().padStart(2, '0');
        const day = date.getDate().toString().padStart(2, '0');
        return `${year}-${month}-${day}`;
    }

    document.addEventListener('DOMContentLoaded', () => {
        initChart();
        loadAndProcessData(); 
        document.getElementById('generate-btn').addEventListener('click', updateChart);
        document.getElementById('toggle-average-btn').addEventListener('click', toggleAverageProfile);
    });

    function initChart() {
        myChart = echarts.init(chartDiv);
        chartBaseOption = {
            tooltip: {
                trigger: 'axis',
                axisPointer: { type: 'cross' }, 
                formatter: (params) => {
                    let tooltip = `Distance: ${params[0].axisValue}m<br/>`;
                    params.sort((a, b) => (b.value[1] || 0) - (a.value[1] || 0)); 
                    params.forEach(param => {
                        if (param.value[1] !== null && param.value[1] !== undefined) {
                            tooltip += `${param.marker} ${param.seriesName}: ${param.value[1].toFixed(1)} Kmph<br/>`;
                        }
                    });
                    return tooltip;
                }
            },
            toolbox: { 
                show: true,
                feature: {
                    dataZoom: { yAxisIndex: 'none' },
                    dataView: { readOnly: false },
                    magicType: { type: ['line', 'bar'] },
                    restore: {},
                    saveAsImage: {},
                    legendToggle: {
                        show: true,
                        title: 'Toggle Legend',
                        icon: 'path://M4,5h16v2H4V5zM4,11h16v2H4V11zM4,17h16v2H4V17z',
                        onclick: function () {
                            const currentOption = myChart.getOption();
                            myChart.setOption({ legend: { show: !currentOption.legend[0].show } });
                        }
                    }
                }
            },
            grid: { left: '3%', right: '4%', bottom: '3%', top: '12%', containLabel: true },
            xAxis: { type: 'value', name: 'Distance to Stop (m)', min: 0, max: 1000, inverse: true },
            yAxis: { type: 'value', name: 'Speed (Kmph)', min: 0, max: 120 },
            title: { text: 'Stop Approach Speed Analysis' },
            legend: { show: false, data: [], type: 'scroll', top: 30 },
            series: []
        };
        myChart.setOption(chartBaseOption);
    }

    function toggleAverageProfile() {
        showOnlyAverage = !showOnlyAverage;
        document.getElementById('toggle-average-btn').textContent = showOnlyAverage ? 'Show All Profiles' : 'Show Only Average Profile';
        updateChart();
    }

    async function loadAndProcessData() {
        try {
            await new Promise((resolve) => gapi.load('client', resolve));
            await gapi.client.init({
                'apiKey': API_KEY,
                'discoveryDocs': ['https://sheets.googleapis.com/$discovery/rest?version=v4'],
            });
            const response = await gapi.client.sheets.spreadsheets.values.get({
                spreadsheetId: SHEET_ID,
                range: RANGE,
            });
            const rawData = response.result.values;
            if (!rawData || rawData.length === 0) { throw new Error("No data found in sheet."); }
            
            const { minDate, maxDate } = preprocessData(rawData); 
            populateFilters(minDate, maxDate); 
            setupAllFilterLogic(); 

            loadingDiv.style.display = 'none'; 
            filtersPanel.style.display = 'flex'; 

        } catch (error) {
            console.error('Error loading data:', error);
            loadingDiv.innerText = "Error loading data. Check console.";
        }
    }

    // --- 3. UPDATED PREPROCESS LOGIC (JSON Parsing) ---
    function preprocessData(rawData) {
        processedData = [];
        lpSet.clear();
        locationSet.clear();
        
        let minDate = null; 
        let maxDate = null; 

        // Start loop from index 1 (skip header)
        for (let i = 1; i < rawData.length; i++) {
            const row = rawData[i];
            if (!row || row.length < 5) continue; 
            
            const timestampStr = (row[COLS.TIMESTAMP] || "").trim();
            const currentTimestamp = timestampStr ? new Date(timestampStr) : null;
            
            if (!currentTimestamp || isNaN(currentTimestamp)) continue;

            const lpId = (row[COLS.LP_ID] || "").trim();
            const lpName = (row[COLS.NAME] || "").trim();
            const trainNo = (row[10] || "").trim(); // Col K is Index 10
            const rakeType = (row[COLS.RAKE_TYPE] || "GOODS").toUpperCase();
            
            // --- CRITICAL: Parse JSON from Column V ---
            const jsonStr = row[COLS.STOPS_JSON];
            let stops = [];
            try {
                if (jsonStr && jsonStr !== "[]") {
                    stops = JSON.parse(jsonStr);
                }
            } catch (e) {
                console.warn("Invalid JSON in row " + (i+1), e);
                continue;
            }

            // Loop through each stop in the JSON array
            stops.forEach(stop => {
                if (!stop.speedsBefore || stop.speedsBefore.length < 5) return;

                // Stop object structure from analysis:
                // speedsBefore: [v1000, v800, v500, v100, v50]
                const s1000 = parseFloat(stop.speedsBefore[0]);
                const s800  = parseFloat(stop.speedsBefore[1]);
                const s500  = parseFloat(stop.speedsBefore[2]);
                const s100  = parseFloat(stop.speedsBefore[3]);
                const s50   = parseFloat(stop.speedsBefore[4]);

                const graphData = [[1000, s1000], [800, s800], [500, s500], [100, s100], [50, s50], [0, 0]];
                const stopLocation = stop.stopLocation || "Unknown";

                if (lpId) lpSet.add(lpId);
                locationSet.add(stopLocation);

                processedData.push({
                    date: currentTimestamp,
                    dateStr: formatDateToInput(currentTimestamp),
                    trainNo: trainNo,
                    lpId: lpId,
                    name: lpName,
                    location: stopLocation,
                    rakeType: rakeType, 
                    km: stop.kilometer || '',
                    graphData: graphData
                });
            });

            if (!minDate || currentTimestamp < minDate) minDate = currentTimestamp;
            if (!maxDate || currentTimestamp > maxDate) maxDate = currentTimestamp;
        }
        
        return { minDate, maxDate };
    }

    function populateFilters(minDate, maxDate) {
        const lpList = document.getElementById('lp-filter-list');
        const locationList = document.getElementById('location-filter-list');
        
        let lpHtml = '<div><label><input type="checkbox" id="lp-all" class="filter-all" checked> <strong>ALL</strong></label></div>';
        [...lpSet].sort().forEach(lp => {
            lpHtml += `<div><label><input type="checkbox" class="lp-item" value="${lp}" checked> ${lp}</label></div>`;
        });
        lpList.innerHTML = lpHtml;

        let locHtml = '<div><label><input type="checkbox" id="location-all" class="filter-all" checked> <strong>ALL</strong></label></div>';
        [...locationSet].sort().forEach(loc => {
            locHtml += `<div><label><input type="checkbox" class="location-item" value="${loc}" checked> ${loc}</label></div>`;
        });
        locationList.innerHTML = locHtml;

        if (minDate) document.getElementById('from-date').value = formatDateToInput(minDate);
        if (maxDate) document.getElementById('to-date').value = formatDateToInput(maxDate);
    }

    // ... (Filter logic functions remain same: filterCheckboxes, setupAllFilterLogic) ...
    function filterCheckboxes(inputId, listId) {
        let input = document.getElementById(inputId);
        let filter = input.value.toUpperCase();
        let list = document.getElementById(listId);
        let items = list.getElementsByTagName('div');
        for (let i = 1; i < items.length; i++) { 
            let label = items[i].getElementsByTagName('label')[0];
            if (label) {
                let txtValue = label.textContent || label.innerText;
                items[i].style.display = txtValue.toUpperCase().indexOf(filter) > -1 ? "" : "none";
            }
        }
    }

    function setupAllFilterLogic() {
        function setupCheckboxLogic(allCheckboxId, itemClassName) {
            const allCb = document.getElementById(allCheckboxId);
            const itemCbs = document.querySelectorAll(`.${itemClassName}`);
            allCb.addEventListener('change', () => itemCbs.forEach(cb => cb.checked = allCb.checked));
            itemCbs.forEach(cb => {
                cb.addEventListener('change', () => {
                    if (!cb.checked) allCb.checked = false;
                    else if ([...itemCbs].every(c => c.checked)) allCb.checked = true;
                });
            });
        }
        setupCheckboxLogic('lp-all', 'lp-item');
        setupCheckboxLogic('location-all', 'location-item');
        setupCheckboxLogic('rake-all', 'rake-item');
        document.querySelectorAll('#rake-filter input[type="checkbox"]:not(#rake-all)').forEach(cb => cb.classList.add('rake-item'));
    }

    function calculateAverageSeries(filteredStops) {
        if (filteredStops.length === 0) return null;
        const sums = { 1000: 0, 800: 0, 500: 0, 100: 0, 50: 0, 0: 0 };
        const counts = { 1000: 0, 800: 0, 500: 0, 100: 0, 50: 0, 0: 0 };
        
        for (const stop of filteredStops) {
            for (const point of stop.graphData) {
                const distance = point[0];
                const speed = point[1];
                if (sums.hasOwnProperty(distance) && speed !== null && !isNaN(speed)) { 
                    sums[distance] += speed; 
                    counts[distance]++; 
                }
            }
        }
        
        const avgData = [
            [1000, counts[1000] > 0 ? sums[1000] / counts[1000] : null],
            [800, counts[800] > 0 ? sums[800] / counts[800] : null],
            [500, counts[500] > 0 ? sums[500] / counts[500] : null],
            [100, counts[100] > 0 ? sums[100] / counts[100] : null],
            [50, counts[50] > 0 ? sums[50] / counts[50] : null],
            [0, 0]
        ];

        return {
            name: `Average Profile (${filteredStops.length} stops)`,
            type: 'line', data: avgData, smooth: true, symbol: 'none',
            color: '#c23531', lineStyle: { width: 4, type: 'dashed', color: '#c23531' },
            emphasis: { lineStyle: { width: 6 } }
        };
    }

    function updateChart() {
        function getCheckedValues(allCheckboxId, itemClassName) {
            if (document.getElementById(allCheckboxId).checked) return ['ALL'];
            let values = [];
            document.querySelectorAll(`.${itemClassName}:checked`).forEach(cb => values.push(cb.value));
            return values;
        }

        const selectedLps = getCheckedValues('lp-all', 'lp-item');
        const selectedLocations = getCheckedValues('location-all', 'location-item');
        const selectedRakes = getCheckedValues('rake-all', 'rake-item');
        const allRakesChecked = document.getElementById('rake-all').checked;

        const fromDateStr = document.getElementById('from-date').value;
        const toDateStr = document.getElementById('to-date').value;
        let fromDate = fromDateStr ? new Date(fromDateStr) : null;
        let toDate = toDateStr ? new Date(toDateStr) : null;
        if (toDate) toDate.setHours(23, 59, 59, 999);

        const filteredData = processedData.filter(stop => {
            const lpMatch = selectedLps.includes('ALL') || selectedLps.includes(stop.lpId);
            const locationMatch = selectedLocations.includes('ALL') || selectedLocations.includes(stop.location);
            const rakeMatch = allRakesChecked || selectedRakes.includes(stop.rakeType);
            const dateMatch = (!fromDate || stop.date >= fromDate) && (!toDate || stop.date <= toDate);
            return lpMatch && locationMatch && rakeMatch && dateMatch;
        });

        const recentValue = document.getElementById('recent-filter').value;
        let displayData = filteredData;
        if (recentValue !== 'all') {
            displayData = filteredData.slice(-parseInt(recentValue));
        }

        chartDiv.style.display = 'block';
        myChart.resize(); 

        if (displayData.length === 0) {
            myChart.setOption({ ...chartBaseOption, title: { text: 'No matching data', left: 'center', top: 'center' }, series: [] }, true);
            return;
        }
        
        const avgSeries = calculateAverageSeries(displayData);
        let finalSeries = avgSeries ? [avgSeries] : [];
        let subtext = showOnlyAverage ? `Showing only average of ${displayData.length} stops.` : null;

        if (!showOnlyAverage) {
            if (displayData.length > LINE_LIMIT) {
                subtext = `Showing average of ${displayData.length} stops. (Too many to show individually)`;
            } else {
                const seriesData = displayData.map((stop, index) => ({
                    name: `LP ${stop.lpId} (${stop.name}) @ ${stop.location}`,
                    type: 'line', smooth: true, symbol: 'none',
                    lineStyle: { width: 2, opacity: 0.7 },
                    data: stop.graphData,
                    emphasis: { focus: 'series', lineStyle: { width: 4, opacity: 1 } },
                    color: COLOR_PALETTE[index % COLOR_PALETTE.length]
                }));
                finalSeries.push(...seriesData);
            }
        }
        
        myChart.setOption({
            ...chartBaseOption,
            title: { text: 'Stop Approach Speed Analysis', subtext: subtext, left: 'auto', top: 'auto' },
            legend: { ...chartBaseOption.legend, data: finalSeries.map(s => s.name) },
            series: finalSeries
        }, true);
    }
</script>
